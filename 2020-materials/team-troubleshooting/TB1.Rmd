---
title: "Team Troubleshooting Deliverable 1"
author: "Icíar Fernández Boyano"
date: "27/08/2020"
output: html_document
---

## This will be removed when the worksheet is complete - 

+ 30 errors
+ topic: dplyr 
+ subtopics:
  + select
  + filter
  + mutate
  + arrange
  + summarize
  + join 
  
## Instructions

There are **30 errors** in this Rmd. Will you find them all?

+ *20 errors are marked* by ## ERROR HERE ## in the code chunk in which they are located.
+ *10 errors are hiding.* Hint: You should be able to knit the script if all code is working correctly...

**Notes:**

+ Errors may be in the form of *broken code* (e.g. using " " inappropriately, which returns an error when running the code), but can also be running code that *does not follow the instructions* (e.g. the goal of the code was to filter the first 3 rows, but instead, the first 3 columns were selected). Read the Rmd commentary carefully to find these.

+ A code chunk with multiple errors, whether broken code or wrongly followed instructions, *counts as a single error for the purpose of grading*.

## Troubleshooting time! 

There are 30 errors in this Rmd. Will you be the one to find them all? More than 1 error in a single chunk of code counts as a **single** error. 
  
```{r}
### ERROR HERE ###
libraries(dslabs)
libraries(tidyverse)
libraries(stringr)
```

[MovieLens](https://dl.acm.org/doi/10.1145/2827872) are a series of datasets widely used in education, that describe movie ratings from the MovieLens [website](https://movielens.org/). There are several MovieLens datasets, collected by the [GroupLens Research Project](https://grouplens.org/datasets/movielens/) at the University of Minnesota. Here, we load the MovieLens 100K dataset from Rafael Irizarry and Amy Gill's R package, [DSLabs](https://cran.r-project.org/web/packages/dslabs/dslabs.pdf), which contains datasets useful for data analysis practice, homework, and projects in data science courses and workshops. 

### Exercise 1

Let's have a look at the dataset! My goal is to:

+ Find out the "class" of the dataset.
+ If it isn't a tibble already, coerce it into a tibble and store it in the variable "movieLens".
+ Have a quick look at the rows and columns, using a *dplyr function*.

```{r}
### ERROR HERE ###
class(dslabs::movielens)
movieLens <- as_tibble(dslabs::movielens)
dim(movieLens)
```

### Exercise 2

Now that we've had a quick look at the dataset, it would be interesting to explore the rows (observations) in some more detail. I'd like to know how many movie entries...

+ Belong to the genre *"Drama"*?
+ Don't belong to the genre *"Drama"*?
+ Were filmed *after* the year 2000?
+ Have a rating of *4.5 or greater*?
+ Were filmed in 1999 *or* 2000?
+ Correspond to the movie *"Little Women"*?
+ Have *more than* 4.5 stars, and were released *before* 1995?

```{r}
filter(movieLens, genres == "Drama")
filter(movieLens, !genres == "Drama")
filter(movieLens, year >= 2000)
filter(movieLens, rating < 4.5)
filter(movieLens, year == 1999 | month == 2000)
filter(movieLens, title %in% "Little Women")
filter(movieLens, rating > 4.5, year < 1995)
```

### Exercise 3

While filtering for *all movies that do not belong to the genre drama* above, I noticed something interesting. I want to filter for the same thing again, this time selecting variables **title and genres first,** and then *everything else*. Hint: there is a function to select "everything else"...

```{r}
### ERROR HERE ###
movieLens %>%
  filter(!genres == "Drama") %>%
  select(title, genres, year, rating, timestamp)
```

Notice that some movies appear to have several genres, instead of a single one. If we filter for the movie "Dumbo" and select the genres column, we see that "Animation|Children|Drama|Musical" appear as genres.

```{r}
movieLens %>%
  title == "Dumbo" %>%
  select(genres)
```

This means that when we filter for "Drama", we are only filtering for those movies that are classified as *exclusively* Drama. What if we want to see all movies that *contain* "Drama" in their genres, even if they are a Romance-Drama, or a Comedy-Drama? Here is a handy, **error-free** expression that can help you do that. No errors, only for learning.

```{r}
movieLens %>%
  filter(str_detect(genres, "Drama"))
```

Now that you know that, select (and filter, where required!):

+ All colums *except* those from userId to timestamp (inclusive)
+ Columns year, title, and genres (in that order) *only* for movies classified *exclusively* as "Romance"
+ Columns rating, title, and year (in that order) followed by everything else (all other columns), only for movies *containing* the genre "Comedy"

```{r}
### ERROR HERE ###
select(movieLens, -(userId:timestamp))

movieLens %>%
  filter(genres == "Romance") %>%
  select(year, title, genres)

movieLens %>%
  filter(str_select(genres, Romance)) %>%
  select(year, title, genres)
```

### Exercise 4

Some of our variables are currently in *camelCase* (in fact, *movieLens* is in camelCase). Let's clean these two variables to be *snake_case* instead, and assign our post-rename object back to "movieLens".

```{r}
movieLens <-
movieLens %>%
  rename(user_id == userId,
         movie_id == movieId)
```

As you already know, mutate() defines and inserts new variables into a tibble. There is *another mystery function* that you've seen already that adds the new variable, and drops existing ones. I wanted to create an average_rating column that takes the mean(rating) across all entries, and I only want to see that variable (i.e drop all others!) but I forgot what that mystery function is. Can you remember?

```{r}
### ERROR HERE ### 
mutate(movieLens,
       average_rating = mean(rating))
```

## Work in progress

Here are expressions that I have written so far and would be interesting for introducing dplyr errors, but that would need to be reframed into exercises as above.

```{r}
movieLens %>%
  filter(year == 1998) %>%
  arrange(desc(rating)) %>%
  select(rating, title, everything())

movieLens %>%
  select(title, year, rating) %>%
  group_by(year) %>%
  arrange(year, rating) 

movieLens %>%
  group_by(title) %>%
  tally()

movieLens %>%
  group_by(year) %>%
  tally()

movieLens%>%
  count(year) 

movieLens %>%
  group_by(title) %>%
  filter(n() > 1) %>%
  summarize(n = n()) %>%
  arrange(n)

filter(movieLens, title == "15 Minutes")

summary(movieLens1.0$year)
summary(movieLens1.0$rating)

movieLens  %>%
  group_by(year) %>%
  summarize(n = n(),
            n_titles = n_distinct(title)) 

movieLens %>%
  group_by(rating) %>%
  summarize(n = n(),
            n_titles = n_distinct(year)) 

movieLens %>%
  group_by(year) %>%
  summarize(avg_rating = mean(rating))

movieLens %>%
  group_by(title) %>%
  summarize(avg_rating = mean(rating))

movieLens %>%
  filter(year %in% c(1952, 2007)) %>%
  group_by(title, year) %>%
  summarize_at(vars(rating), list(~mean(.), ~median(.)))

movieLens %>%
  group_by(title) %>%
  summarize(min_rating = min(rating), max_rating = max(rating))

# are there movies that have gained ratings during the years?
movieLens %>% 
  group_by(title) %>% 
  select(title, year, rating) %>% 
  mutate(rating_gain = rating - first(rating)) %>% 
  filter(year < 1963)

# working on this one as an adjustment of jenny bryan's "grand finale" in the dplyr STAT545 chapter https://stat545.com/dplyr-single.html#grand-finale
movieLens  %>%
  select(title, year, rating) %>%
  group_by(title, year) %>%
  ## within title, take (rating in year i) - (rating in year i - 1)
  ## positive means rating went up, negative means it went down
  mutate(rating_delta = rating - lag(rating)) %>% 
  ## within each year, retain the worst rating change = smallest or most negative
  summarize(worst_rating_delta = min(rating_delta, na.rm = TRUE)) %>% 
  ## within title, retain the row with the lowest worst_rating_delta
  top_n(-1, wt = worst_rating_delta) %>% 
  arrange(worst_rating_delta)
```

