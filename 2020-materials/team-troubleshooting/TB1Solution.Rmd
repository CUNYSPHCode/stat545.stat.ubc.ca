---
title: "Team Troubleshooting Deliverable 1"
author: "Icíar Fernández Boyano"
date: "27/08/2020"
output: html_document
---

+ 30 exercises
+ read in a dataset
+ topic: dplyr with errors
+ subtopic:
  + select
  + filter
  + mutate
  + arrange
  + summarize
  + join 
  
## Introduction

## Instructions

There are **30 errors** in this Rmd. Will you find them all?

+ *20 errors are marked* (at least the general area in which they are located) by ## ERROR HERE ## in the code chunk.
+ *10 errors are hiding.* Hint: You should be able to knit the script if all code is working correctly...
+ Errors may be in the form of *broken code* (e.g. using " " inappropriately, which returns an error when running the code), but can also be running code that *does not follow the instructions* (e.g. the goal of the code was to filter the first 3 rows, but instead, the first 3 columns were selected). Read the Rmd commentary carefully to find these.

## Troubleshooting time! 

There are 30 errors in this Rmd. Will you be the one to find them all? More than 1 error in a single chunk of code counts as a **single** error. 
  
```{r}
### SOLUTION HERE ###
library(dslabs)
library(tidyverse)
```

[MovieLens](https://dl.acm.org/doi/10.1145/2827872) are a series of datasets widely used in education, that describe movie ratings from the MovieLens [website](https://movielens.org/). There are several MovieLens datasets, collected by the [GroupLens Research Project](https://grouplens.org/datasets/movielens/) at the University of Minnesota. Here, we load the MovieLens 100K dataset from Rafael Irizarry and Amy Gill's R package, [DSLabs](https://cran.r-project.org/web/packages/dslabs/dslabs.pdf), which contains datasets useful for data analysis practice, homework, and projects in data science courses and workshops. 

### Exercise 1

Let's have a look at the dataset! My goal is to:

+ Find out the "class" of the dataset.
+ If it isn't a tibble already, coerce it into a tibble and store it in the variable "movieLens".
+ Have a quick look at the rows and columns, using a *dplyr function*.

```{r}
class(dslabs::movielens)
movieLens <- as_tibble(dslabs::movielens)
glimpse(movieLens) ### SOLUTION HERE ###
```

```{r}
filter(movieLens, genres == "Drama")
filter(movieLens, !genres == "Drama")
filter(movieLens, year > 2000) ### SOLUTION HERE ###
filter(movieLens, rating >= 4.5) ### SOLUTION HERE ###
filter(movieLens, year == 1999 | month == 2000)
filter(movieLens, title == "Little Women") ### SOLUTION HERE ###
filter(movieLens, rating > 4.5, year < 1995) 
```

### Exercise 2

Now that we've had a quick look at the dataset, it would be interesting to explore the rows (observations) in some more detail. I'd like to know how many movie entries...

+ Belong to the genre *"Drama"*?
+ Don't belong to the genre *"Drama"*?
+ Were filmed *after* the year 2000?
+ Have a rating of *4.5 or greater*?
+ Were filmed in 1999 *or* 2000?
+ Correspond to the movie *"Little Women"*?
+ Have *more than* 4.5 stars, and were released *before* 1995?

```{r}
filter(movieLens, genres == "Drama")
filter(movieLens, !genres == "Drama")
filter(movieLens, year > 2000) ### SOLUTION HERE ###
filter(movieLens, rating >= 4.5) ### SOLUTION HERE ###
filter(movieLens, year == 1999 | month == 2000)
filter(movieLens, title == "Little Women") ### SOLUTION HERE ###
filter(movieLens, rating > 4.5, year < 1995)
```

### Exercise 3

While filtering for *all movies that do not belong to the genre drama* above, I noticed something interesting. I want to filter for the same thing again, this time selecting variables **title and genres first,** and then *everything else*. Hint: there is a function to select "everything else"...

```{r}
movieLens %>%
  filter(!genres == "Drama") %>%
  select(title, genres, everything()) ### SOLUTION HERE ###
```

Notice that some movies appear to have several genres, instead of a single one. If we filter for the movie "Dumbo" and select the genres column, we see that "Animation|Children|Drama|Musical" appear as genres.

```{r}
movieLens %>%
  filter(title == "Dumbo") %>% ### SOLUTION HERE ###
  select(genres)
```

This means that when we filter for "Drama", we are only filtering for those movies that are classified as *exclusively* Drama. What if we want to see all movies that *contain* "Drama" in their genres, even if they are a Romance-Drama, or a Comedy-Drama? Here is a handy, **error-free** expression that can help you do that. No errors, only for learning.

```{r}
movieLens %>%
  filter(str_detect(genres, "Drama"))
```

Now that you know that, select (and filter, where required!):

+ All colums *except* those from userId to timestamp (inclusive)
+ Columns year, title, and genres (in that order) *only* for movies classified *exclusively* as "Romance"
+ Columns rating, title, and year (in that order) followed by everything else (all other columns), only for movies *containing* the genre "Comedy"

```{r}
select(movieLens, -(userId:timestamp))

movieLens %>%
  filter(genres == "Romance") %>%
  select(year, title, genres)

movieLens %>%
  filter(str_select(genres, "Comedy")) %>% ### SOLUTION HERE ###
  select(year, title, genres)
```

### Exercise 4

Some of our variables are currently in *camelCase* (in fact, *movieLens* is in camelCase). Let's clean these two variables to be *snake_case* instead, and assign our post-rename object back to "movieLens".

```{r}
movieLens <-
movieLens %>%
  rename(user_id = userId,
         movie_id = movieId) ### SOLUTION HERE ###
```

As you already know, mutate() defines and inserts new variables into a tibble. There is *another mystery function* that you've seen already that adds the new variable, and drops existing ones. I wanted to create an average_rating column that takes the mean(rating) across all entries, and I only want to see that variable (i.e drop all others!) but I forgot what that mystery function is. Can you remember?

```{r}
transmute(movieLens,
          average_rating = mean(rating)) ### SOLUTION HERE ###
```
